const axios = require('axios');
const simpleGit = require('simple-git');
const fs = require('fs-extra');
const path = require('path');

class GitHubService {
  constructor() {
    this.token = process.env.GITHUB_TOKEN;
    this.username = process.env.GITHUB_USERNAME;
    this.apiUrl = 'https://api.github.com';
  }

  async createFixPR(repoUrl, fixes, scanId) {
    console.log('üîÄ Creating GitHub PR with security fixes...');
    
    try {
      // Parse repository information
      const repoInfo = this.parseRepoUrl(repoUrl);
      if (!repoInfo) {
        throw new Error('Invalid repository URL');
      }

      // Clone repository
      const workDir = path.join(__dirname, '../../temp', `pr-${scanId}`);
      await fs.ensureDir(workDir);
      
      const git = simpleGit();
      await git.clone(repoUrl, workDir);
      
      const repoGit = simpleGit(workDir);
      
      // Create a new branch for fixes
      const branchName = `security-fixes-${scanId}`;
      await repoGit.checkoutLocalBranch(branchName);
      
      // Apply fixes
      const appliedFixes = [];
      for (const fix of fixes) {
        try {
          if (fix.confidence >= 0.7) { // Only apply high-confidence fixes
            await this.applyFixToRepo(fix, workDir);
            appliedFixes.push(fix);
          }
        } catch (error) {
          console.error(`Failed to apply fix: ${error.message}`);
        }
      }

      if (appliedFixes.length === 0) {
        console.log('No high-confidence fixes to apply');
        await fs.remove(workDir);
        return null;
      }

      // Commit changes
      await repoGit.add('.');
      await repoGit.commit(`üîí Security fixes: ${appliedFixes.length} vulnerabilities addressed

Automated security fixes generated by CyberSecScan:
${appliedFixes.map(fix => `- ${fix.file}: ${fix.issue}`).join('\n')}

Scan ID: ${scanId}`);

      // Push branch
      await repoGit.push('origin', branchName);

      // Create pull request
      const prData = await this.createPullRequest(repoInfo, branchName, appliedFixes, scanId);
      
      // Clean up
      await fs.remove(workDir);
      
      return {
        prUrl: prData.html_url,
        prNumber: prData.number,
        branch: branchName,
        appliedFixes: appliedFixes.length,
        fixes: appliedFixes
      };

    } catch (error) {
      console.error('Failed to create PR:', error);
      throw error;
    }
  }

  parseRepoUrl(repoUrl) {
    // Support both HTTPS and SSH URLs
    const httpsMatch = repoUrl.match(/https:\/\/github\.com\/([^\/]+)\/([^\/]+?)(?:\.git)?$/);
    const sshMatch = repoUrl.match(/git@github\.com:([^\/]+)\/([^\/]+?)(?:\.git)?$/);
    
    const match = httpsMatch || sshMatch;
    if (match) {
      return {
        owner: match[1],
        repo: match[2]
      };
    }
    
    return null;
  }

  async applyFixToRepo(fix, repoPath) {
    if (fix.type === 'semgrep') {
      const filePath = path.join(repoPath, fix.file);
      const content = await fs.readFile(filePath, 'utf8');
      const fixedContent = content.replace(fix.originalCode, fix.fixedCode);
      await fs.writeFile(filePath, fixedContent, 'utf8');
    } else if (fix.type === 'trivy') {
      const packageJsonPath = path.join(repoPath, 'package.json');
      if (await fs.pathExists(packageJsonPath)) {
        const packageJson = await fs.readJson(packageJsonPath);
        
        if (packageJson.dependencies && packageJson.dependencies[fix.packageName]) {
          packageJson.dependencies[fix.packageName] = fix.fixedVersion;
        }
        if (packageJson.devDependencies && packageJson.devDependencies[fix.packageName]) {
          packageJson.devDependencies[fix.packageName] = fix.fixedVersion;
        }
        
        await fs.writeJson(packageJsonPath, packageJson, { spaces: 2 });
      }
    }
  }

  async createPullRequest(repoInfo, branchName, fixes, scanId) {
    const title = `üîí Automated Security Fixes (${fixes.length} vulnerabilities)`;
    
    const body = this.generatePRDescription(fixes, scanId);

    const response = await axios.post(
      `${this.apiUrl}/repos/${repoInfo.owner}/${repoInfo.repo}/pulls`,
      {
        title,
        body,
        head: branchName,
        base: 'main' // or 'master', could be made configurable
      },
      {
        headers: {
          'Authorization': `token ${this.token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      }
    );

    return response.data;
  }

  generatePRDescription(fixes, scanId) {
    const semgrepFixes = fixes.filter(f => f.type === 'semgrep');
    const trivyFixes = fixes.filter(f => f.type === 'trivy');

    let description = `## üîí Automated Security Fixes

This PR contains automated security fixes generated by CyberSecScan.

### üìä Summary
- **Total Fixes**: ${fixes.length}
- **SAST Fixes**: ${semgrepFixes.length}
- **Dependency Fixes**: ${trivyFixes.length}
- **Scan ID**: \`${scanId}\`

`;

    if (semgrepFixes.length > 0) {
      description += `### üîç Static Analysis Fixes (Semgrep)

| File | Issue | Confidence |
|------|-------|------------|
`;
      semgrepFixes.forEach(fix => {
        description += `| \`${fix.file}\` | ${fix.issue} | ${Math.round(fix.confidence * 100)}% |\n`;
      });
      description += '\n';
    }

    if (trivyFixes.length > 0) {
      description += `### üì¶ Dependency Updates (Trivy)

| Package | Current | Fixed | Vulnerability |
|---------|---------|-------|---------------|
`;
      trivyFixes.forEach(fix => {
        description += `| \`${fix.packageName}\` | ${fix.currentVersion} | ${fix.fixedVersion} | ${fix.issue} |\n`;
      });
      description += '\n';
    }

    description += `### ‚ö†Ô∏è Important Notes

- All fixes have been automatically generated and tested for high confidence
- Please review each change carefully before merging
- Consider running your test suite to ensure functionality is preserved
- This PR was created by an automated security scanning tool

### ü§ñ About CyberSecScan

CyberSecScan is an AI-powered security platform that automatically detects and fixes vulnerabilities in your code. Learn more at [cyber.io](https://github.com/Habib9612/cyber.io).

---
*Generated automatically by CyberSecScan v1.0.0*`;

    return description;
  }

  async getRepositoryInfo(repoUrl) {
    const repoInfo = this.parseRepoUrl(repoUrl);
    if (!repoInfo) {
      throw new Error('Invalid repository URL');
    }

    try {
      const response = await axios.get(
        `${this.apiUrl}/repos/${repoInfo.owner}/${repoInfo.repo}`,
        {
          headers: {
            'Authorization': `token ${this.token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        }
      );

      return {
        name: response.data.name,
        fullName: response.data.full_name,
        description: response.data.description,
        language: response.data.language,
        stars: response.data.stargazers_count,
        forks: response.data.forks_count,
        defaultBranch: response.data.default_branch
      };
    } catch (error) {
      console.error('Failed to get repository info:', error);
      throw error;
    }
  }

  async createPRComment(repoFullName, prNumber, comment) {
    const [owner, repo] = repoFullName.split('/');
    
    try {
      const response = await axios.post(
        `${this.apiUrl}/repos/${owner}/${repo}/issues/${prNumber}/comments`,
        { body: comment },
        {
          headers: {
            'Authorization': `token ${this.token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        }
      );

      return response.data;
    } catch (error) {
      console.error('Failed to create PR comment:', error);
      throw error;
    }
  }
}

module.exports = new GitHubService();
